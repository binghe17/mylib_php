<?php
//内存 628.64 KB（默认使用情况，什么都没开辟时）（系统自己预定义一些内存空间。
//这些默认使用到的内存空间可能是，全局常量，全局变量，全局函数等。）
class tool{
	//大小转换
	function int_size($size){
		$unit=array('B','KB','MB','GB','TB','PB');
		return @round($size/pow(1024,($i=floor(log($size,1024)))),2).' '.$unit[$i];
	}
	//CPU运行时间 cpu_runtime
	function cpu_runtime($type=0){
		if($type==0) define('RUNTIME',microtime(1));
		if($type==1) {$tm=microtime(1)-RUNTIME; return 'CPU: '.$tm;}
	}
	//内存使用大小 memory_usage
	function memory_usage(){
		return 'MEM: '. $this->int_size(memory_get_usage());//631.21 KB（只开辟工具类的CPU占用大小）
		//注释不是放入到内存中，内存中放入的有，主入口文件所运行到的代码，如变量，函数定义，使用 等。
		//运行函数才引入函数体内的include指向的页面中的这些定义（变量定义，函数定义，类定义，使用所需要的内存空间）
		//
		//使用前，使用后（也可以看做成，程序运行开始到现在为止所使用到的内存）
		//类是脚本完全结束后才清理内存空间（默认）。函数是使用完以后立即清理内存空间。
		//变量是unset后便清理内存空间。。简单理解为，使用到内存就占用空间，不需要了就会释放内存空间。
		//
		//上一次与这一次的内存只差是，现在的内存使用空间情况减去上一次的内存使用空间情况。
		//函数体外自己计算，不在函数体内写了。
	}
}
$t=new tool();
$t->cpu_runtime();
echo $t->memory_usage();//631.21 KB（默认使用情况，什么都没开辟时）
echo '<br>';

//--------------------类定义-------------------------------------
class a{
	public $a=10;
	public $b=20;

	function fun1(){
		return $a+$b;
	}

	function __destruct(){
		echo 'close ' .__CLASS__;
	}
}

//--------------------动态类使用1

$a=new a();
for ($i=0; $i < 100000 ; $i++) {
	echo $a->fun1();
}
//100000次 0.213794946671 （动态类测试）
//A类开辟后，使用前 636.67 KB 使用后 637.93 KB

//--------------------动态类使用2

// for ($i=0; $i < 100000 ; $i++) {
// 	$a=new a();
// 	echo $a->fun1();
// }
//100000次 0.39241194725 （动态类测试）
//A类开辟后，使用前 636.67 KB 使用后 637.93 KB（开辟之后的情况）


//每一次新开辟空间是，对内存新开辟空间，
//同样的A类，第二次建立的时候，他会自动关闭，第一次建立的A类，然后再一次新开辟空间
//所以，内存使用情况是不会变。
//每一次开辟空间和，删除空间上，消耗CPU速度，开辟之后一直使用的话，跟普通的函数块一样快。



//-------------------静态类使用

// class a{
// 	static public $a=10;
// 	static public $b=20;

// 	public static function fun1(){
// 		return $a+$b;
// 	}

// 	//静态类不需要析构函数
// }


// for ($i=0; $i < 100000 ; $i++) {
// 	echo a::fun1();
// }
//100000次 0.30606508255 (静态类测试)
//静态类使用前 636.17 KB 使用后 636.9 KB
//100000次 0.227770090103 （前面加static时）
//静态类使用前 636.59 KB 使用后 637.31 KB




//-----------------------普通类方式，（全局域上的使用）--------------------

// $a=10;
// $b=20;

// function fun1(){
// 	return $a+$b;
// }

// for ($i=0; $i < 100000 ; $i++) {
// 	echo fun1();
// }
//100000次 0.196352005005 （普通函数测试）
//函数使用前633.66 KB 使用后634.66 KB


//---------------------------------------------------------
//总结：function 的方式。写代码缺点
//1.不能重复函数名，都要写在全局空间上，不能有函数体内的函数形式，写不好可能会出错。
//2.代码名会很长，不容易记忆。代码看起来一团乱。不好分析。（一头雾水）（不能分清哪些是私用成员）
//原以为，类CPU速度很慢，然后MEM占用也很多，调试结果发现，动态类不比，普通函数慢。
//
//总结：class 的方式。的好处
//1.继承，多态，封装，等等。。类好处就不多说了。（所以大家都用类的吧）（速度慢的误区总算逃出来了）
//2.书写代码规整，容易分析思路，
//3.使用层面也，更容易理解。一个类，也可以实例化很多，同时使用的变量空间块很多。
//4.自己写的代码（变量名和函数名）与别人写的（变量名和函数名）不会被冲突，因为作用域不同。
//
//原先使用函数时，把数据都放在数组上，处理，复制
//但是使用类以后，把数据可以放到。类空间变量上（不用放到全局变量上），空间作用域不同，
//所以变量不会被干扰。提取变量也方便。只要遵循类的使用写法就可以了。
//
//原以为。JS与PHP数据交互用JSON文件来完成。现在看来，也不一定要如此。
//用正则提取为数组，然后用数组在组合成规定格式的PHP代码字符串，所以不一定要用JSON规范来保存数据文件。
//用PHP原生代码也可以提取想要的。部分到数组，然后再JSON ，然后给客户端，客户端处理后在接收JSON数据
//然后用JSON 数据在转换成PHP代码串来保存。所有过程都可以随意的操作。还是原生代码效率快。数组就
//原生PHP数组格式array()格式来保存数据。比JSON格式或序列化格式，XML格式等其他格式要快很多。
//但以后使用类的话，把有结构的数据，一定要序列化来保存数据。
//
//一个变量是一个对象（新的全局空间）。变量上可以放数据，也可以放函数。（函数与类的最大区别是空间域的限制）
//用PHP程序来制作有规律的（PHP代码，JS代码，HTML，CSS等字符串），生成的这些字符串文件，直接使用到程序运作上。
//
//最后，原先决定不用类而决定函数与数组形式的书写代码的初衷也是，效率，内存等因素来决定的。
//发现普通函数方式的效率，不比类快很多时，他的缺点，不足之处层次不穷的出来。
//还有，静态类快，动态类慢的说法是错误的。
//（最后！类还是好啊！决定用类了！）

//-----------------------------------------------------




//------------------------类测速
// class a{
// 	function fun(){
// 		return 'aaaaaa';
// 	}
// }

// //使用时的消耗内存空间（类使用时）
// $bb=new a();
// for ($i=0; $i < 10000 ; $i++) { 
// 	$a[]=$bb->fun();	//CPU: 0.00750207901001  MEM: 2.33 MB
// }

//定义时的内存使用空间（new空间时）
// for ($i=0; $i < 10000 ; $i++) {
// 	$a[]=new a();		//CPU: 0.00956583023071  MEM: 4.95 MB
// }


//-------------------------函数测速

// function fun(){
// 	return 'aaaaaa';
// }
// //使用时的消耗内存空间（普通函数方式，全局空间上）
// for ($i=0; $i < 10000 ; $i++) { 
// 	$a[]=fun();//CPU: 0.00490283966064  MEM: 2.33 MB
// }



//----------include的速度，一万次。获取变量
for ($i=0; $i < 10000 ; $i++) { 
	$arr=include('var.txt');//10000次 MEM: 3.4 MB  CPU: 0.490394115448
}
print_r($arr);
	/* --------var.txt的内容--------
		<?php
		return array(
			'aa'=>'aaaaa',
			'bb'=>'bbbb'
		);
	------------------------------ */




//-----------------------------------------------------

// echo '<pre>';
// print_r($GLOBALS);
// echo '</pre>';

echo '<br>';
echo $t->memory_usage(); // 631.8 KB（开辟之后的情况）
echo '<br>';
echo $t->cpu_runtime(1);
